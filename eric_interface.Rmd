---
title: "Interfacing with ERIC"
author: "Tim Ransom"
date: "10/22/2021"
output: html_document
runtime: shiny
---
<!-- We need to remove this to include in the user interface -->
<!-- ```{r setup, include=FALSE} -->
<!-- knitr::opts_chunk$set(echo = TRUE) -->
<!-- print("hello") -->
<!-- ``` -->

## Search terms

We're representing our search terms as a list of lists, where the top level elements
are AND'd and the lower level elements are OR'd. For example: ((a, b, c), (d, e))
represents "a OR b OR c" AND "d OR e"

Here's the full list of terms we're going to make our queries out of:
```{r}
search_terms <- list(list("community college", "higher education", "postsecondary education"),
                     list("pandemic", "COVID-19"),
                     list("online courses", "online learning",
                        "educational technology", "distance education", "electronic learning"),
                     list("hands on", "lab"),
                     list("FAA", "part 147"))

test_searh_terms <- list(list("community college", "higher education"),
                         list("online learning", "distance education"))
```


## Powerset construction

We need to try all the combinations of our search terms, which mathematically
is the cartesian product of the powersets of our full list above.

A table showing the cartesian product of the search "(a OR b) AND (1 OR 2)"
```{text}
|    | a   | b   | ab   |     "" |
|  1 | a1  | b1  | ab1  |      1 |
|  2 | a2  | b2  | ab2  |      2 |
| 12 | a12 | b12 | ab12 |     12 |
| "" | a   | b   | ab   | REMOVE |
```

```{r}
term_powerset <- function(search_terms) {
  # Create the powersets and convert empty values to empty vector
  rapply(mapply(rje::powerSet, search_terms), function(x) {
    if (length(x) == 0) {
      return(c(""))
    } else {
      return(x)
    }
  }, how = "replace")
}

two_dimentional_cartesian_product <- function(first_powerset, second_powerset) {
    # This function does not take advantage of R magic too much so it can probably be optimized
    # Also it only works with two powersets with the same size

    # We initialize some variables
    out <- list()
    i <- 1

    # We loop through all the values in second powerset
    for (operand in second_powerset) {
      # We combine every thing from the first powerset with the current element in the second powerset
      out[[i]] <- mapply(function(x) { append(x, operand) }, first_powerset)
      # We move to the next index in the out list and get the next element in the second powerset
      i <- i + 1
    }

    # We trim the whitespace of each product and return the resulting list
    return(out)
  }

format_powerset <- function(powerset) {
  # We turn the powersets into a one dimensional list so we can format each set with a space in between
  compacted_list <- mapply(paste, powerset, MoreArgs = list(collapse = " "))
  
  # We then need to split the list by empty strings so that we can use each powerset individually
  split(compacted_list, cumsum(data.frame(compacted_list)[, 1] == ""))
}


recursive_cartesian_product <- function(powersets, index = 1) {
  # This check is for when we want to stop recursion
  # It also acts as a way to calculate a two dimensional product without recursion
  if (index + 1 ==  length(powersets[1, ])) {
    out <- two_dimentional_cartesian_product(powersets[, index], powersets[, index + 1])
  }
  else {
    # When we need to calculate a three or more dimension cartesian product we first calculate the product of the first two powersets.
    # Then we calculate another two dimensional product using the next powerset as the first operand and the result of the previous calculation as the second
    out <- two_dimentional_cartesian_product(powersets[, index],
                                        recursive_cartesian_product(powersets, index + 1))
  }
  trimmed_out <- rapply(out, function(x) { x[x != ""] }, how = "replace")
  
  # Trim the empty results
  return(trimmed_out)
}

cartesian_product <- function(powersets) {
  # We use our recursive cartesian product function to calculate the product using our formatted powersets
  out <- recursive_cartesian_product(powersets)
  
  # Our recursive cartesian product function returns a list of lists of lists which is one too many lists so we have to unlist it
  return(unlist(out, recursive = FALSE))
}
```


## ERIC communications

### Utility functions
We use a couple functions to talk to the ERIC api, one to format the query for
the database request and one to talk to ERIC.

```{r}
get_eric_json <- function(encoded_url) {
  library(curl)
  library(rjson)

  # variable left out for future caching opportunity
  req <- curl_fetch_memory(encoded_url)
  return(fromJSON(rawToChar(req$content)))
}


# All possible fields can be found here: https://eric.ed.gov/?api#/default/get_eric_
# possible interesting additions: language, publicationtype, publicationdateyear
# magic numbers:
#   rows - max ERIC lets one pull to API be
#   start - adjust to daisy-chain queries together when there are more than 2000 (unimplemented)
create_eric_url <- function(search_terms, start = 0, rows = 2000,
                            fields = list(list("*"), list("peerreviewed", "'T'"))) {

  # unlikely to change, we only care about ERIC at the moment
  eric_base_url <- "https://api.ies.ed.gov/eric/"
  # we've selected json over xml for parsing and efficiency purposes
  format <- "json"
  
  # two one liners to form our search term logical expression and the field modification encoding
  formatted_terms <- paste(mapply(function(x) {paste(unlist(x), collapse = " OR ")}, search_terms), collapse = " AND ")
  formatted_fields <- paste(mapply(function(x) {paste(unlist(x), collapse = ":")}, fields), collapse = " ")
  
  unencoded_url <- paste(eric_base_url, 
                           "?search=", formatted_terms, 
                           "&format=", format, 
                           "&start=", start,
                           "&rows=", rows, 
                           "&fields=", formatted_fields, 
                           sep = "")
  
  return(URLencode(unencoded_url)) # urltools::url_encode broke api compatibility, using utils::URLencode instead
}
```

### Talking to ERIC

Here's the putting-it-all-together for this file. I've just put in some untested
skeleton code here of how I see it fitting together. This is the last backend task before
we jump into the GUI reactive stuff.

```{r}
#all_eric_term_queries <- "" # TODO: use smaller test terms, term_powerset(test_search_terms)
#all_eric_urls <- "" # TODO: map the list of searchs through create_eric_url
#all_eric_json_results <- list() # TODO: this is likely better represented with an R dataframe, if so, should we convert after all api queries or during loop?

# TODO: is this better iteratively or can we do some parallel network hits? I don't see ERIC docs talking about that
# for (eric_url in all_eric_urls) {
  # TODO: write some of these to files that we can use for testing
  # eric_json <- get_eric_json(eric_url)

  # all_eric_json_results.append(eric_json)
# }

# print out the human readable version of the search query and the number of results for it
# just a two column list to STDOUT is good for now, just want to see it somewhere other than the R env
```
