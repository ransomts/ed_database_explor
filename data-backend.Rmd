---
title: "Interfacing with ERIC"
author: 
  - "Tim Ransom"
  - "Moss Gallagher"
date: \today
output: html_document
runtime: shiny
---

# Data structure


```{r define-test-groups}
search_terms <- list(list("community college", "higher education", "postsecondary education"),
                     list("pandemic", "COVID-19"),
                     list("online courses", "online learning",
                        "educational technology", "distance education", "electronic learning"),
                     list("hands on", "lab"),
                     list("FAA", "part 147"))

test_search_terms <- list(list("community college", "higher education"),
                         list("online learning", "distance education"))
```

## Build term sets


Input string - 'FAA OR Part 147'
output - tibble with fill binary set

developer choice to not support terms with ' OR ' inside them
```{r def-make-set}
make_set <- function(input_terms) {
  term_list <- unlist(str_split(input_terms, " OR "))
  tib <- bind_rows(setNames(rep(0, length(term_list)), term_list))[0,]
  return(tib)
}

test_set_a <- make_set("A OR B")
View(test_set_a)
test_set_b <- make_set("C OR D")
test_set_c <- make_set("E OR F OR G")
```

```{r def-set-to-group}
set_to_group <- function(set, ...){
  
  nth_bit <- function(i, n) { bitwAnd(bitwShiftR(i, n - 1), 1) }
  
  tib <- tibble(set, ...)
  tib_len <- length(tib)
  
  for (i in 2:2^tib_len - 1) {
    tib %<>% add_row(!!! setNames(map(1:tib_len, ~ nth_bit(i, .)), names(.)))
  }
  
  inital_set_names <- set %>% names %>% paste0(collapse = "_")
  #tib %<>% nest(!!inital_set_names := names(set))
  tib %<>% nest("{inital_set_names}" := names(set))

  for (extra_set in list(...)) {
    extra_set_names <- extra_set %>% names %>% paste0(collapse = "_")
    tib %<>% nest("{extra_set_names}" := names(extra_set))
  }

  # TODO add meta data to group tib
  #tib %<>% map(format_group_to_query)

  return(tib)
}


test_group_a <- set_to_group(test_set_a)
test_group_a %>% View
test_group_b <- set_to_group(test_set_c, test_set_b) 
test_group_b %>% View
```

```{r def-group-to-explor}
group_to_explor <- function(group) {
  return(group %>% add_column(eric = NA, proquest = NA))
}
```


```{r get-eric-view-from-group}
format_group_to_query <- function(group) {

  binary_recode <- function(data, term) {
    if (data == 0) {
      return("")
    }
    return(term)
  }
  binary_recode <- Vectorize(binary_recode)

  # TODO possible spoc for optimization, pre filter group to only compute needed queries

  set_names <- group %>% names
  query_acc <- c()
  for (set_name in set_names) {
    #browser()

    terms <- set_name %>% str_split("_") %>% pluck(1)
    group_tmp <- group %>% select(set_name) %>% unnest(c(set_name))
    
    for (term in terms) {
      
      group_tmp %<>% 
        mutate(!!term := binary_recode(!!sym(term), term)) 
    }
    
    query_acc %<>% append(list(group_tmp %>%
                          reduce(paste) %>%
                          str_squish() %>%
                          str_replace_all(pattern = " ", replacement = " OR ")))
  }

  a <- enframe(query_acc) %>% unnest(value)

  enframed_acc <- expand_grid(query_acc[[1]]) %>% unnest
  
  if (length(query_acc) > 1) {
    for (i in 2:length(query_acc)) {
      enframed_acc %<>% expand_grid(query_acc[[i]]) %>% unnest
    }
  }
  
  return(enframed_acc %>% 
           reduce(paste) %>% 
           str_squish() %>% 
           str_replace_all(pattern = "(?<!OR) (?!OR)", replacement = " AND ") %>% 
           unique)
}

make_query <- function(...) {
  tmp_names <- ...names()
  new_names <- c()
  for (i in 1:...length()) {
    if (...elt(i) == 1) {
      new_names %<>% append(tmp_names[i])
    }
  }
  
  if (length(new_names) > 1) {
    new_names %<>% paste(collapse = " OR ")
  } else if (length(new_names) == 0) {
    new_names <- ""
  }
  return(new_names)
}

format_group_to_query(test_group_b)

get_eric_counts <- function(group) {
  
}


get_eric_values <- function(explor) {
  
}
```

