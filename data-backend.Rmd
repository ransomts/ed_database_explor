---
title: "Interfacing with ERIC"
author: 
  - "Tim Ransom"
  - "Moss Gallagher"
date: \today
output: html_document
runtime: shiny
---

# Libraries

```{r}
library(tidyverse)
library(magrittr)
library(curl)
library(rjson)
```
# Convienience Functions

```{r}
fully_unnest_tibble <- function(tib) {
  unnested_tib <- tib
  for (col_name in tib %>% names) {
    unnested_tib %<>% unnest(cols = c(!!col_name))
  }
  return(unnested_tib)
}

expan_grid <- function(tib, group) {
  tib_acc <- c()
  group_acc <- c()
  for (element in group) {
    for (col in tib) {
      for (val in col) {
        tib_acc %<>% append(val)
        group_acc %<>% append(element)
      }
    }
  }
  
  print(tib_acc)
  print(group_acc)
  
  return(tibble(tib_acc, group_acc))
}
```


# Data structure

```{r define-test-groups}
search_terms <- list(list("community college", "higher education", "postsecondary education"),
                     list("pandemic", "COVID-19"),
                     list("online courses", "online learning",
                        "educational technology", "distance education", "electronic learning"),
                     list("hands on", "lab"),
                     list("FAA", "part 147"))

test_search_terms <- list(list("community college", "higher education"),
                         list("online learning", "distance education"))
```

## Build term sets


Input string - 'FAA OR Part 147'
output - tibble with fill binary set

developer choice to not support terms with ' OR ' inside them
```{r def-make-set}
make_set <- function(input_terms) {
  term_list <- unlist(str_split(input_terms, " OR "))
  tib <- bind_rows(setNames(rep(FALSE, length(term_list)), term_list))[0,]
  return(tib)
}

test_set_a <- make_set("A OR B")
View(test_set_a)
test_set_b <- make_set("C OR D")
test_set_c <- make_set("E OR F OR G")
test_set_d <- make_set("H OR I")
test_set_e <- make_set("J OR K OR L")
test_set_f <- make_set("M OR N OR O OR P")
```

## Build group

make a full group from a collection of sets

This is where the ANDs are put into the queries
```{r def-set-to-group}
set_to_group <- function(set, ...){
  
  generate_name_from_set <- function(set) {
    return(set %>% names %>% paste0(collapse = "_"))
  }
  
  nth_bit <- function(i, n) { bitwAnd(bitwShiftR(i, n - 1), 1) }
  
  tib <- tibble(set, ...)
  tib_len <- length(tib)
  
  for (i in 2:2^tib_len - 1) {
    tib %<>% add_row(!!! setNames(map(1:tib_len, ~ nth_bit(i, .)), names(.)))
  }
  
  inital_set_names <- set %>% generate_name_from_set
  #tib %<>% nest(!!inital_set_names := names(set))
  tib %<>% nest("{inital_set_names}" := names(set))

  for (extra_set in list(...)) {
    extra_set_names <- extra_set %>% generate_name_from_set
    tib %<>% nest("{extra_set_names}" := names(extra_set))
  }

  # TODO add meta data to group tib
  #tib %<>% map(format_group_to_query)

  return(tib)
}


test_group_a <- set_to_group(test_set_a)
test_group_a %>% View
test_group_b <- set_to_group(test_set_c, test_set_b) 
test_group_b %>% View
test_group_c <- set_to_group(test_set_d, test_set_e, test_set_f)
```

## Make queries

Format the group/set data structure to a string that we can pass to our search
engines

For example:
> A OR B AND C

```{r get-eric-view-from-group}
make_queries_for_group <- function(group) {

  combine_augmented_sets <- function(set_a, set_b) {

    combined_acc <- bind_cols(set_a %>%
                                slice(0) %>%
                                select(-query),
                              set_b %>%
                                slice(0))
    
    for (a_slice_index in 1:nrow(set_a)) {
      a_slice <- set_a %>% slice(a_slice_index)
      
      for (b_slice_index in 1:nrow(set_b)) {
        b_slice <- set_b %>% slice(b_slice_index)
        
        a_query <- select(a_slice, query)
        b_query <- select(b_slice, query)
        
        combined_query <- paste(select(a_slice, query), 
                                select(b_slice, query), sep = " AND ") 
        
        if (a_query == "" || b_query == "") {
          combined_query <- paste0(select(a_slice, query), select(b_slice, query))
        }
        
        a_terms <- a_slice %>% select(-query)
        b_terms <- b_slice %>% select(-query)
        
        
        combined_acc %<>% add_row(bind_cols(a_terms, b_terms, 
                                            query = combined_query))
      }
    }
    
    return(combined_acc)
  }
  
  make_queries_for_set <- function(set) {
    
    make_query <- function(...) {
      tmp_names <- ...names()
      new_names <- c()
      for (i in 1:...length()) {
        if (...elt(i) == 1) {
          new_names %<>% append(tmp_names[i])
        }
      }
      
      if (length(new_names) > 1) {
        new_names %<>% paste(collapse = " OR ")
      } else if (length(new_names) == 0) {
        new_names <- ""
      }
      return(new_names)
    }
    
    return(pmap_chr(set, .f = make_query))
  }
  
  set_names <- group %>% names
  
  augmented_set_tibs <- c()
  for (set_name in set_names) {
    
    set_tib <- group %>%
      select(set_name) %>%
      unnest(cols = c(set_name)) %>% 
      unique
    
    augmented_set_tib <- set_tib %>% 
      add_column("query" := make_queries_for_set(set_tib))
    
    augmented_set_tibs %<>% append(list(augmented_set_tib))
  }
  
  aug_query_tib_acc <- augmented_set_tibs[1] %>% pluck(1)
  if (length(augmented_set_tibs) >= 2) {
    
    for (i in 2:length(augmented_set_tibs)) {
      
      aug_query_tib_acc %<>% combine_augmented_sets(augmented_set_tibs[i] %>% pluck(1))
    }
  }
  
  return(aug_query_tib_acc)
}


make_queries_for_group(test_group_a)
test_query_b <- make_queries_for_group(test_group_b)
test_query_c <- make_queries_for_group(test_group_c)
```

## Make full explor data structure

```{r def-group-to-explor}
group_to_explor <- function(group) {
  return(group %>% add_column(eric = NA, proquest = NA))
}


explor_a <- group_to_explor(make_queries_for_group(test_group_a))
explor_b <- group_to_explor(make_queries_for_group(test_group_b))
explor_c <- group_to_explor(make_queries_for_group(test_group_c))
```

```{r get-eric-view-from-group}

fully_unnest_tibble <- function(tib) {
  unnested_tib <- tib 
  for (col_name in tib %>% names) {
    unnested_tib %<>% unnest(cols = c(!!col_name))
  }
  return(unnested_tib)
}


expan_grid <- function(tib, group) {
  tib_acc <- c()
  group_acc <- c()
  for (element in group) {
    for (col in tib) {
      for (val in col) {
        tib_acc %<>% append(val)
        group_acc %<>% append(element)
      }
    }
  }
  
  return(tibble(tib_acc, group_acc))
}

format_group_to_query <- function(group) {

  binary_recode <- function(data, term) {
    if (data == 0) {
      return("")
    }
    return(term)
  }
  binary_recode <- Vectorize(binary_recode)

  # TODO possible spoc for optimization, pre filter group to only compute needed queries

  set_names <- group %>% names
  query_acc <- c()
  for (set_name in set_names) {
    #browser()

    terms <- set_name %>% str_split("_") %>% pluck(1)
    group_tmp <- group %>% select(set_name) %>% unnest(c(set_name))
    
    for (term in terms) {
      
      group_tmp %<>% 
        mutate(!!term := binary_recode(!!sym(term), term)) 
    }
    
    query_acc %<>% append(list(group_tmp %>%
                          reduce(paste) %>%
                          str_squish() %>%
                          str_replace_all(pattern = " ", replacement = " OR ")))
  }

  a <- enframe(query_acc) %>% unnest(value)

  enframed_acc <- expand_grid(query_acc[[1]]) %>% unnest
  
  if (length(query_acc) > 1) {
    for (i in 2:length(query_acc)) {
      enframed_acc %<>% expan_grid(query_acc[[i]]) %>% unnest
    }
  }
  
  return(enframed_acc %>% 
           reduce(paste) %>% 
           str_squish() %>% 
           str_replace_all(pattern = "(?<!OR) (?!OR)", replacement = " AND ") %>% 
           unique)
}

make_query <- function(...) {
  tmp_names <- ...names()
  new_names <- c()
  for (i in 1:...length()) {
    if (...elt(i) == 1) {
      new_names %<>% append(tmp_names[i])
    }
  }
  
  if (length(new_names) > 1) {
    new_names %<>% paste(collapse = " OR ")
  } else if (length(new_names) == 0) {
    new_names <- ""
  }
  return(new_names)
}

format_group_to_query(test_group_a)
test_query_b <- format_group_to_query(test_group_b)
test_group_b %>% fully_unnest_tibble %>% add_column(test_query_b[!test_query_b %in% c("")]) %>% View
test_query_against_group(test_query_b, test_group_b)
test_query_c <- format_group_to_query(test_group_c)

create_eric_url <- function(search_terms, start = 0, rows = 2000,
                            fields = list(list("*"), list("peerreviewed", "'T'"))) {

  # unlikely to change, we only care about ERIC at the moment
  eric_base_url <- "https://api.ies.ed.gov/eric/"
  # we've selected json over xml for parsing and efficiency purposes
  format <- "json"
  
  # two one liners to form our search term logical expression and the field modification encoding
  formatted_terms <- paste(mapply(function(x) {paste(unlist(x), collapse = " OR ")}, search_terms), collapse = " AND ")
  formatted_fields <- paste(mapply(function(x) {paste(unlist(x), collapse = ":")}, fields), collapse = " ")
  
  unencoded_url <- paste(eric_base_url, 
                           "?search=", formatted_terms, 
                           "&format=", format, 
                           "&start=", start,
                           "&rows=", rows, 
                           "&fields=", formatted_fields, 
                           sep = "")
  
  return(URLencode(unencoded_url)) # urltools::url_encode broke api compatibility, using utils::URLencode instead
}


get_eric_count <- function(str) {
  eric_url <- create_eric_url(str)

  # variable left out for future caching opportunity
  req <- curl_fetch_memory(eric_url)
  json_resp <- fromJSON(rawToChar(req$content))
  return(json_resp$response$numFound)
}

test_count <- get_eric_count("A AND B")

```
