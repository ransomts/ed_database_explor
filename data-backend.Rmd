---
title: "Interfacing with ERIC"
author: 
  - "Tim Ransom"
  - "Moss Gallagher"
date: \today
output: html_document
runtime: shiny
---

# Libraries

```{r}
library(tidyverse)
library(magrittr)
```
# Convienience Functions

```{r}
fully_unnest_tibble <- function(tib) {
  unnested_tib <- tib
  for (col_name in tib %>% names) {
    unnested_tib %<>% unnest(cols = c(!!col_name))
  }
  return(unnested_tib)
}

expan_grid <- function(tib, group) {
  tib_acc <- c()
  group_acc <- c()
  for (element in group) {
    for (col in tib) {
      for (val in col) {
        tib_acc %<>% append(val)
        group_acc %<>% append(element)
      }
    }
  }
  
  print(tib_acc)
  print(group_acc)
  
  return(tibble(tib_acc, group_acc))
}
```


# Data structure

```{r define-test-groups}
search_terms <- list(list("community college", "higher education", "postsecondary education"),
                     list("pandemic", "COVID-19"),
                     list("online courses", "online learning",
                        "educational technology", "distance education", "electronic learning"),
                     list("hands on", "lab"),
                     list("FAA", "part 147"))

test_search_terms <- list(list("community college", "higher education"),
                         list("online learning", "distance education"))
```

## Build term sets


Input string - 'FAA OR Part 147'
output - tibble with fill binary set

developer choice to not support terms with ' OR ' inside them
```{r def-make-set}
make_set <- function(input_terms) {
  term_list <- unlist(str_split(input_terms, " OR "))
  tib <- bind_rows(setNames(rep(FALSE, length(term_list)), term_list))[0,]
  return(tib)
}

test_set_a <- make_set("A OR B")
View(test_set_a)
test_set_b <- make_set("C OR D")
test_set_c <- make_set("E OR F OR G")
test_set_d <- make_set("H OR I")
test_set_e <- make_set("J OR K OR L")
test_set_f <- make_set("M OR N OR O OR P")
```

## Build group

make a full group from a collection of sets

This is where the ANDs are put into the queries
```{r def-set-to-group}
set_to_group <- function(set, ...){
  
  generate_name_from_set <- function(set) {
    return(set %>% names %>% paste0(collapse = "_"))
  }
  
  nth_bit <- function(i, n) { bitwAnd(bitwShiftR(i, n - 1), 1) }
  
  tib <- tibble(set, ...)
  tib_len <- length(tib)
  
  for (i in 2:2^tib_len - 1) {
    tib %<>% add_row(!!! setNames(map(1:tib_len, ~ nth_bit(i, .)), names(.)))
  }
  
  inital_set_names <- set %>% generate_name_from_set
  #tib %<>% nest(!!inital_set_names := names(set))
  tib %<>% nest("{inital_set_names}" := names(set))

  for (extra_set in list(...)) {
    extra_set_names <- extra_set %>% generate_name_from_set
    tib %<>% nest("{extra_set_names}" := names(extra_set))
  }

  # TODO add meta data to group tib
  #tib %<>% map(format_group_to_query)

  return(tib)
}


test_group_a <- set_to_group(test_set_a)
test_group_a %>% View
test_group_b <- set_to_group(test_set_c, test_set_b) 
test_group_b %>% View
test_group_c <- set_to_group(test_set_d, test_set_e, test_set_f)
```

## Make queries

Format the group/set data structure to a string that we can pass to our search
engines

For example:
> A OR B AND C

```{r get-eric-view-from-group}
make_queries_for_group <- function(group) {

  combine_augmented_sets <- function(set_a, set_b) {

    combined_acc <- bind_cols(set_a %>%
                                slice(0) %>%
                                select(-query),
                              set_b %>%
                                slice(0))
    
    for (a_slice_index in 1:nrow(set_a)) {
      a_slice <- set_a %>% slice(a_slice_index)
      
      for (b_slice_index in 1:nrow(set_b)) {
        b_slice <- set_b %>% slice(b_slice_index)
        
        a_query <- select(a_slice, query)
        b_query <- select(b_slice, query)
        
        combined_query <- paste(select(a_slice, query), 
                                select(b_slice, query), sep = " AND ") 
        
        if (a_query == "" || b_query == "") {
          combined_query <- paste0(select(a_slice, query), select(b_slice, query))
        }
        
        a_terms <- a_slice %>% select(-query)
        b_terms <- b_slice %>% select(-query)
        
        
        combined_acc %<>% add_row(bind_cols(a_terms, b_terms, 
                                            query = combined_query))
      }
    }
    
    return(combined_acc)
  }
  
  make_queries_for_set <- function(set) {
    
    make_query <- function(...) {
      tmp_names <- ...names()
      new_names <- c()
      for (i in 1:...length()) {
        if (...elt(i) == 1) {
          new_names %<>% append(tmp_names[i])
        }
      }
      
      if (length(new_names) > 1) {
        new_names %<>% paste(collapse = " OR ")
      } else if (length(new_names) == 0) {
        new_names <- ""
      }
      return(new_names)
    }
    
    return(pmap_chr(set, .f = make_query))
  }
  
  set_names <- group %>% names
  
  augmented_set_tibs <- c()
  for (set_name in set_names) {
    
    set_tib <- group %>%
      select(set_name) %>%
      unnest(cols = c(set_name)) %>% 
      unique
    
    augmented_set_tib <- set_tib %>% 
      add_column("query" := make_queries_for_set(set_tib))
    
    augmented_set_tibs %<>% append(list(augmented_set_tib))
  }
  
  aug_query_tib_acc <- augmented_set_tibs[1] %>% pluck(1)
  if (length(augmented_set_tibs) >= 2) {
    
    for (i in 2:length(augmented_set_tibs)) {
      
      aug_query_tib_acc %<>% combine_augmented_sets(augmented_set_tibs[i] %>% pluck(1))
    }
  }
  
  return(aug_query_tib_acc)
}


make_queries_for_group(test_group_a)
test_query_b <- make_queries_for_group(test_group_b)
test_query_c <- make_queries_for_group(test_group_c)
```

## Make full explor data structure

```{r def-group-to-explor}
group_to_explor <- function(group) {
  return(group %>% add_column(eric = NA, proquest = NA))
}


explor_a <- group_to_explor(make_queries_for_group(test_group_a))
explor_b <- group_to_explor(make_queries_for_group(test_group_b))
explor_c <- group_to_explor(make_queries_for_group(test_group_c))
```
