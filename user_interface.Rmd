---
title: "user_interface"
output: html_document
runtime: shiny
---

```{r setup, echo=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Library interface

```{r echo=FALSE}
# Import eric interface
library(stringr)
library(purrr)
library(ggplot2)
library(knitr)
library(shiny)
library(miniUI)
```

We pull in our eric functions from eric_interface.Rmd
```{r}
source(knitr::purl("eric_interface.Rmd", output = tempfile(), quiet = TRUE))
```


## Inputs and Outputs

Term groups are comma deliminated, and newline separated
For example:

> foo, bar
>
> foobie

is interpreted as

> ("foo" OR "bar") AND ("foobie")


Just a button that executes a hard coded ERIC search query, which is then displayed below

```{r echo=FALSE}

plot_size <- 160


format_terms_input_to_search <- function(search_terms) {
  # TODO: Remove leading spaces from split inputs (More info below)

  # We split the string on new lines then pass the array of split strings to mapply which splits each line on commas
  split_input <-
    mapply(strsplit,
           strsplit(search_terms, "\n"),
           MoreArgs = list(split = ","))

  # We then combine the split strings with ORs on the same line and each line separated with ANDs
  # When we combine with ORs it produces a double space. This is because we're splitting on comma without the following space.
  # This could be changed if we want to disallow commas without spaces after or we could trim the spaces after.
  return(paste("terms: ", paste(
    mapply(paste, split_input, MoreArgs = list(collapse = " or ")), collapse = " and "
  )))
}

# search_terms is the string input from the terms_input textArea
format_terms_input_to_list <- function(search_terms) {
  # split on newlines to search term groups
  term_groups <- t(stringr::str_split(search_terms, "\n", simplify = TRUE))

  # split term groups on comma, needs whitespace trimmed from terms
  terms_list <- mapply(function(x) {
    stringr::str_split(x, ",")
  }, term_groups)

  return(rapply(terms_list, trimws, how = "replace"))
}

format_product_into_string <- function(product) {
    # We need to split on the same value as what is used in format_powerset
    mapply(function(x) { strsplit(x, "```") }, product)
}

product_is_empty <- function(product) {
  # First we create a list of booleans with each element representing if that index is not an empty string.
  # Then check if any are true
  return(!any(mapply(function(x) { return(x != "") }, product) == TRUE))
}

product_contains_empty <- function(product) {
  # First we create a list of booleans with each element representing if that index is not an empty string.
  # Then check if any are false
  return(any(mapply(function(x) { return(x != "") }, product) == FALSE))
}
```


## Input Panel
```{r echo=FALSE}

empty_space <- "--"

terms <- list()

# Helper Functions
split_terms_string <- function(str) {
    cartesian_product_of_terms <- str %>%
    format_terms_input_to_list %>%
    term_powerset %>%
    format_powerset %>%
    purrr::cross()
  
  cartesian_product_of_terms <- cartesian_product_of_terms[!mapply(product_is_empty, cartesian_product_of_terms)]

  contains_empty <- 
    cartesian_product_of_terms %>% 
    map(product_contains_empty)
  formatted_products <- cartesian_product_of_terms %>% 
    map(function(x) { return(x[x != ""]) }) %>%
    map(format_product_into_string)
  
  return(formatted_products)
}

##   formatted_products <- cartesian_product_of_terms %>% 
##    map(function(x) { return(x[x != ""]) }) %>%
##    map(format_product_into_string)

search_eric_from_products <- function(formatted_products, options) {
  
  eric_urls <- formatted_products %>%
    map(function(x) { create_eric_url(x, rows = 20, fields = list(list("peerreviewed", "'T'"))) })
 
  readable_terms <- mapply(function(product) {
      paste(mapply(function(x) { 
          paste(unlist(x), collapse = " or ")}, product), collapse = " and ") }, formatted_products)
  
  eric_responses <- list()

  withProgress(message = "Searching ERIC\n", value = 0, {
    # Number of times we'll go through the loop
    n <- length(eric_urls)

    for (i in 1:n) {
      eric_responses[[i]] <- get_eric_json(eric_urls[[i]])

      # Increment the progress bar, and update the detail text.
      incProgress(1 / n, detail = paste("Searching URL", eric_urls[[i]]))
    }
  })
  
  names(eric_responses) <- readable_terms
  
  num_found <- mapply(function(x) { return(x$response$numFound) }, eric_responses)

  names(num_found) <- readable_terms
  
  return(num_found)
}

find_data_by_row_col <- function(row, col, numbers) {
  
  if (row == empty_space && col == empty_space) {
    return(NaN)
  }
    
  if (!(paste(row, "and", col) %in% names(numbers))) {
    row <- paste0(row,col)
    col <- substr(row,0,nchar(row) - nchar(col))
    row <- substr(row,nchar(col) + 1, nchar(row))
  }
      
  if (row == empty_space) {
    find_string <- col
  }
  else if (col == empty_space) {
    find_string <- row
  }
  else {
    find_string <- paste(row, "and", col)
  }
  
  return(numbers[find_string])
}

create_compare_graph <- function(first_set, second_set) {
  first_formatted <- mapply(function(x) {
          paste(unlist(x), collapse = " or ")}, format_product_into_string(first_set))

  first_formatted[[1]] <- empty_space

  second_formatted <- mapply(function(x) {
          paste(unlist(x), collapse = " or ")}, format_product_into_string(second_set))

  second_formatted[[1]] <- empty_space

  compare_matrix <- matrix(nrow = length(first_formatted), ncol = length(second_formatted))

  rownames(compare_matrix) <- first_formatted

  colnames(compare_matrix) <- second_formatted
  
  compare_matrix <- fill_compare_matrix(compare_matrix, num_found_for_terms)
  
  return(renderTable(compare_matrix, align = "l", rownames = TRUE, bordered = TRUE, digits = 0, na = ""))
}

create_summary_graph <- function(set) {
  formatted_set <- mapply(function(x) {
          paste(unlist(x), collapse = " or ")}, format_product_into_string(set))

  formatted_set <- formatted_set[-1]
  
  summary_list <- vector(length = length(formatted_set))
  
  names(summary_list) <- formatted_set
  
  summary_list <- fill_summary_list(summary_list, num_found_for_terms)
  
  summary_df <- data.frame(terms = formatted_set, found = summary_list)
  
  rownames(summary_df) <- NULL
  
  theme_set(theme_classic())
  
  gplot <- ggplot(data = summary_df, aes(x = terms, y = found)) +
    geom_bar(stat = "identity")
  
  gplot <- gplot + scale_y_log10(n.breaks = 10, labels = scales::label_number())
  
  return(renderPlot(gplot + theme(axis.text.x = element_text(size = 10, angle = -90, hjust = 0)), height = 600, width = 400))
}

fill_summary_list <- function(list, numbers) {
  mapply(function(name) {
    list[name] <<- find_data_by_row_col(name, empty_space, numbers)
  }, names(list))

  return(list)
}

fill_compare_matrix <- function(matrix, numbers) {
  mapply(function(rowname) {
    mapply(function(colname) {
    
      matrix[rowname, colname] <<- find_data_by_row_col(rowname, colname, numbers)
      
    }, colnames(matrix))
  }, rownames(matrix))
  
  return(matrix)
}
```

```{r eval=FALSE}
  withProgress(message = "Searching ERIC\n", value = 0, {
    # Number of times we'll go through the loop
    n <- length(formatted_products)

    for (i in 1:n) {
      url <- create_eric_url(formatted_products[[i]], rows = 20, fields = options)
      
      eric_responses[[i]] <- get_eric_json(url)

      # Increment the progress bar, and update the detail text.
      incProgress(1 / n, detail = url)
    }
  })
```

```{r echo=FALSE}

create_ui_gadget <- function() {
  get_css <- function() {
    return("div {
            padding-top: 10px;
            padding-left: 10px;
            padding-right: 10px;
            padding-bottom: 10px;
           }")
  }
  
  num_found_for_terms <- list()

  compare_count <- 1

  summary_count <- 1
  
  # Define UI
  ui <- miniUI::miniPage(
    miniTabstripPanel(miniTabPanel("Search",
  
    # Sidebar layout with input and output definitions
        # Input for terms and options
      fillCol(
      wellPanel(
        textAreaInput("terms", "Terms", value = "FAA, Part 147\ndistance learning, online education"),
        wellPanel(
          tags$h4("Options"),
          checkboxInput("peer", "Peer Reviewed", value = FALSE),
          radioButtons("database", "Database: ",
               c("ERIC" = "eric",
                 "ProQuest" = "proquest"))
        ),
        actionButton("search", "Search", class = "btn-success"),
        br(),
        ))), miniTabPanel("Summary", mainPanel(
          wellPanel(
          plotOutput("summary_graph")
          , align="center")
      )), miniTabPanel("Comparison", mainPanel(
        wellPanel(
          plotOutput("comparison_graph")
          , align="center")
      ))))
  
  server <- function(input, output, session) {
    output$summary_graph <- renderPlot({
      plot(mtcars$wt, mtcars$mpg)
    })
    
    output$comparison_graph <- renderPlot({
      plot(mtcars$wt, mtcars$mpg)
    })
    
  }
  
  runGadget(ui, server)
}


# shinyApp(ui, server, options = list(height = 700))
```
