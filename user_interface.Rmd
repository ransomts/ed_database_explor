---
title: "user_interface"
output: html_document
runtime: shiny
---

```{r setup, echo=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Library interface

```{r echo=FALSE}
# Import eric interface
library(stringr)
library(purrr)
library(ggplot2)
library(knitr)
library(shiny)
```

We pull in our eric functions from eric_interface.Rmd
```{r}
source(knitr::purl("eric_interface.Rmd", output = tempfile(), quiet = TRUE))
```


## Inputs and Outputs

Term groups are comma deliminated, and newline separated
For example:

> foo, bar
>
> foobie

is interpreted as

> ("foo" OR "bar") AND ("foobie")


Just a button that executes a hard coded ERIC search query, which is then displayed below

```{r echo=FALSE}

plot_size <- 160


format_terms_input_to_search <- function(search_terms) {
  # TODO: Remove leading spaces from split inputs (More info below)

  # We split the string on new lines then pass the array of split strings to mapply which splits each line on commas
  split_input <-
    mapply(strsplit,
           strsplit(search_terms, "\n"),
           MoreArgs = list(split = ","))

  # We then combine the split strings with ORs on the same line and each line separated with ANDs
  # When we combine with ORs it produces a double space. This is because we're splitting on comma without the following space.
  # This could be changed if we want to disallow commas without spaces after or we could trim the spaces after.
  return(paste("terms: ", paste(
    mapply(paste, split_input, MoreArgs = list(collapse = " or ")), collapse = " and "
  )))
}

# search_terms is the string input from the terms_input textArea
format_terms_input_to_list <- function(search_terms) {
  # split on newlines to search term groups
  term_groups <- t(stringr::str_split(search_terms, "\n", simplify = TRUE))

  # split term groups on comma, needs whitespace trimmed from terms
  terms_list <- mapply(function(x) {
    stringr::str_split(x, ",")
  }, term_groups)

  return(rapply(terms_list, trimws, how = "replace"))
}

format_product_into_string <- function(product) {
    # We need to split on the same value as what is used in format_powerset
    mapply(function(x) { strsplit(x, "```") }, product)
}

product_is_empty <- function(product) {
  # First we create a list of booleans with each element representing if that index is not an empty string.
  # Then check if any are true
  return(!any(mapply(function(x) { return(x != "") }, product) == TRUE))
}

product_contains_empty <- function(product) {
  # First we create a list of booleans with each element representing if that index is not an empty string.
  # Then check if any are false
  return(any(mapply(function(x) { return(x != "") }, product) == FALSE))
}
```


## Input Panel
```{r echo=FALSE}

empty_space <- "--"

terms <- list()

number_input_boxes <- 1

num_found_for_terms <- list()

# Helper Functions
split_terms_string <- function(str) {
    cartesian_product_of_terms <- str %>%
    format_terms_input_to_list %>%
    term_powerset %>%
    format_powerset %>%
    purrr::cross()
  
  cartesian_product_of_terms <- cartesian_product_of_terms[!mapply(product_is_empty, cartesian_product_of_terms)]

  contains_empty <- 
    cartesian_product_of_terms %>% 
    map(product_contains_empty)
  formatted_products <- cartesian_product_of_terms %>% 
    map(function(x) { return(x[x != ""]) }) %>%
    map(format_product_into_string)
  
  return(formatted_products)
}

##   formatted_products <- cartesian_product_of_terms %>% 
##    map(function(x) { return(x[x != ""]) }) %>%
##    map(format_product_into_string)

search_eric_from_products <- function(formatted_products, options) {
  
  eric_urls <- formatted_products %>%
    map(function(x) { create_eric_url(x, rows = 20, fields = list(list("peerreviewed", "'T'"))) })
 
  readable_terms <- mapply(function(product) {
      paste(mapply(function(x) { 
          paste(unlist(x), collapse = " or ")}, product), collapse = " and ") }, formatted_products)
  
  eric_responses <- list()

  withProgress(message = "Searching ERIC\n", value = 0, {
    # Number of times we'll go through the loop
    n <- length(eric_urls)

    for (i in 1:n) {
      eric_responses[[i]] <- get_eric_json(eric_urls[[i]])

      # Increment the progress bar, and update the detail text.
      incProgress(1 / n, detail = paste("Searching URL", eric_urls[[i]]))
    }
  })
  
  names(eric_responses) <- readable_terms
  
  num_found <- mapply(function(x) { return(x$response$numFound) }, eric_responses)

  names(num_found) <- readable_terms
  
  return(num_found)
}

find_data_by_row_col <- function(row, col, numbers) {
  
  if (row == empty_space && col == empty_space) {
    return(NaN)
  }
    
  if (!(paste(row, "and", col) %in% names(numbers))) {
    row <- paste0(row, col)
    col <- substr(row, 0, nchar(row) - nchar(col))
    row <- substr(row, nchar(col) + 1, nchar(row))
  }
      
  if (row == empty_space) {
    find_string <- col
  }
  else if (col == empty_space) {
    find_string <- row
  }
  else {
    find_string <- paste(row, "and", col)
  }
  
  return(numbers[find_string])
}

create_compare_graph <- function(first_set, second_set) {
  first_formatted <- mapply(function(x) {
          paste(unlist(x), collapse = " or ")}, format_product_into_string(first_set))

  first_formatted[[1]] <- empty_space

  second_formatted <- mapply(function(x) {
          paste(unlist(x), collapse = " or ")}, format_product_into_string(second_set))

  second_formatted[[1]] <- empty_space

  compare_matrix <- matrix(nrow = length(first_formatted), ncol = length(second_formatted))

  rownames(compare_matrix) <- first_formatted

  colnames(compare_matrix) <- second_formatted
  
  compare_matrix <- fill_compare_matrix(compare_matrix, num_found_for_terms)
  
  return(renderTable(compare_matrix, align = "l", rownames = TRUE, bordered = TRUE, digits = 0, na = ""))
}

create_summary_graph <- function(set) {
  formatted_set <- mapply(function(x) {
          paste(unlist(x), collapse = " or ")}, format_product_into_string(set))

  formatted_set <- formatted_set[-1]
  
  summary_list <- vector(length = length(formatted_set))
  
  names(summary_list) <- formatted_set
  
  summary_list <- fill_summary_list(summary_list, num_found_for_terms)
  
  summary_df <- data.frame(terms = formatted_set, found = summary_list)
  
  rownames(summary_df) <- NULL
  
  theme_set(theme_classic())
  
  gplot <- ggplot(data = summary_df, aes(x = terms, y = found)) +
    geom_bar(stat = "identity")
  
  gplot <- gplot + scale_y_log10(n.breaks = 10, labels = scales::label_number())
  
  return(renderPlot(gplot + theme(axis.text.x = element_text(size = 10, angle = -90, hjust = 0)), height = 600, width = 400))
}

fill_summary_list <- function(list, numbers) {
  mapply(function(name) {
    list[name] <<- find_data_by_row_col(name, empty_space, numbers)
  }, names(list))

  return(list)
}

fill_compare_matrix <- function(matrix, numbers) {
  mapply(function(rowname) {
    mapply(function(colname) {
    
      matrix[rowname, colname] <<- find_data_by_row_col(rowname, colname, numbers)
      
    }, colnames(matrix))
  }, rownames(matrix))
  
  return(matrix)
}

get_input_terms <- function(input) {
  terms_list <- list()
  
  sapply(1:number_input_boxes, function(x) {
    terms_list[[length(terms_list) + 1]] <<- input[[paste0("terms", x)]]
  })
  
  return(terms_list)
}
```

```{r eval=FALSE}
  withProgress(message = "Searching ERIC\n", value = 0, {
    # Number of times we'll go through the loop
    n <- length(formatted_products)

    for (i in 1:n) {
      url <- create_eric_url(formatted_products[[i]], rows = 20, fields = options)
      
      eric_responses[[i]] <- get_eric_json(url)

      # Increment the progress bar, and update the detail text.
      incProgress(1 / n, detail = url)
    }
  })
```

```{r echo=FALSE}
# Define UI
ui <- fluidPage(

  titlePanel("Search"),

  # Sidebar layout with input and output definitions
  sidebarLayout(
    
    # Sidebar panel for inputs
    sidebarPanel(

      # Input for terms and options
      textInput("terms1", "Term Set", value = "FAA, Part 147"),
      actionButton("add_term_set", "Add Term Set", class = "btn-success"),
      checkboxInput("peer", "Peer Reviewed", value = FALSE),
      actionButton("search", "Search", class = "btn-primary"),
      br(),
      
    ),

    # Main panel for displaying outputs
    mainPanel(
      
      tags$script("
      var show_compare_table = false
      var show_summary_graph = false
      
      Shiny.addCustomMessageHandler('hide_compare_table', function(message) {
        show_compare_table = false
      });
      
      Shiny.addCustomMessageHandler('show_compare_table', function(message) {
        show_compare_table = true
      })
      
      Shiny.addCustomMessageHandler('set_show_compare_table', function(boolean) {
        show_compare_table = boolean
      })
      
      function compare_table_is_shown() {
        return show_compare_table
      }
      
      Shiny.addCustomMessageHandler('hide_summary_graph', function(message) {
        show_summary_graph = false
      });
      
      Shiny.addCustomMessageHandler('show_summary_graph', function(message) {
        console.log('sct')
        show_summary_graph = true
      })
      
      Shiny.addCustomMessageHandler('set_show_summary_graph', function(boolean) {
        show_summary_graph = boolean
      })
      
      function summary_graph_is_shown() {
        return show_summary_graph
      }
    "),
      
      br(),

      # Output: Dropdown menu for term set selection
      uiOutput("term_dropdown"),
      
      # Output: Button to add a new tab
      uiOutput("add_tab"),
      
      # Output: Tabset w/ summary and comparison
      uiOutput("result_tabset")
    )
  )
)

server <- function(input, output, session) {
  
  observeEvent(input$summary_dropdown, {
  
    if (all(input$summary_dropdown != "")) {
    
    terms_list <- mapply(function(x) { paste(x, collapse = " or ") }, format_terms_input_to_list(terms))
    
    names(terms_list) <- terms_list
    
    # Logic for the summary tab
    output$summary_graph <- create_summary_graph(unlist(str_split(input$summary_dropdown, " or "), recursive = FALSE) %>% powerset %>% format_powerset)
    
    session$sendCustomMessage("show_summary_graph", "")
    
    }
  })
  
  observeEvent(input$compare_dropdown1, {
    
    if (all(input$compare_dropdown1 != "")) {
      
      terms_list <- mapply(function(x) { paste(x, collapse = " or ") }, format_terms_input_to_list(terms))
    
      names(terms_list) <- terms_list
      
      terms_trimmed <- terms_list[!mapply(function(x) { all(input$compare_dropdown1 == x) }, terms_list)]
      
      output$compare_dropdown2 <- renderUI({ selectInput(
      "compare_dropdown2",
      "",
      c("Select A Compare Term Set" = "", terms_trimmed)) })
   
    }   
    else {
    output$compare_dropdown2 <- renderUI({ 
      verbatimTextOutput("placeholder")
      })
    output$placeholder <- renderText({"Select A First Term Set"})
    }
      
  })
  
  
  observeEvent(input$compare_dropdown2, {
    if (all(input$compare_dropdown2 != "")) {
      
    first_term_set <- unlist(str_split(input$compare_dropdown1, " or "), recursive = FALSE) %>% powerset %>% format_powerset
    
    second_term_set <- unlist(str_split(input$compare_dropdown2, " or "), recursive = FALSE) %>% powerset %>% format_powerset
    
    session$sendCustomMessage("show_compare_table", "")
    
    output$compare_table <- create_compare_graph(first_term_set, second_term_set)
    }
  })
  
  observeEvent(input$add_term_set, {
    
    input_box <- textInput(paste0("terms", number_input_boxes + 1), "")
    
    insertUI(
      selector = paste0("#terms", number_input_boxes),
      where = "afterEnd",
      ui = input_box
    )
    
    number_input_boxes <<- number_input_boxes + 1
  })
  
  observeEvent(input$search, {
    
    terms <<- get_input_terms(input)
    
    session$sendCustomMessage("hide_compare_table", "")
    session$sendCustomMessage("hide_summary_graph", "")
    
    formatted_products <- split_terms_string(terms)
    
    options <- list()
    
    if (input$peer) {
      options[[length(options) + 1]] <- list("peerreviewed", "'T'")
    }
    
    if (length(options) == 0) {
      options[[1]] <- list("*")
    }
    
    num_found <- search_eric_from_products(formatted_products, options)
    
    terms_list <- format_terms_input_to_list(formatted_products)
    
    readable_terms <- mapply(function(product) {
      paste(mapply(function(x) {
          paste(unlist(x), collapse = " or ")}, product), collapse = " and ") }, formatted_products)
    
    num_found_for_terms <<- num_found
    
    terms_list <- mapply(function(x) { paste(x, collapse = " or ") }, format_terms_input_to_list(terms))
    
    names(terms_list) <- terms_list
    
    if (length(terms_list) != 1) { 
      
      output$result_tabset <- renderUI({ mainPanel(tabsetPanel(
            tabPanel("Summary", mainPanel(uiOutput("summary_dropdown"), conditionalPanel("summary_graph_is_shown()", plotOutput("summary_graph")))),
            tabPanel("Compare", mainPanel(
                    uiOutput("compare_dropdown1"),
                    uiOutput("compare_dropdown2"),
                    uiOutput("compare_btn"),
                    br(),
                    conditionalPanel("compare_table_is_shown()",
                    tableOutput("compare_table")))))
            ) })
            
            output$compare_dropdown1 <- renderUI({
      selectInput(
      "compare_dropdown1",
      "",
      c("Select A Term Set" = "", terms_list))
      })
    }
    else {
      output$result_tabset <- renderUI({ tabsetPanel(type = "tabs",
      id = "result_tabset",
      tabPanel("Summary", mainPanel(plotOutput("summary_graph")))) })
    }
    
    output$summary_dropdown <- renderUI({
      selectInput(
      "summary_dropdown",
      "",
      c("Select A Term Set" = "", terms_list))
      })
    
  })

}

shinyApp(ui, server, options = list(height = 700))
```
