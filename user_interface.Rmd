---
title: "user_interface"
output: html_document
runtime: shiny
---

```{r setup, echo=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Library interface

```{r echo=FALSE}
# Import eric interface
library(stringr)
library(purrr)
library(ggplot2)
library(knitr)
library(shiny)
```

We pull in our eric functions from eric_interface.Rmd
```{r}
source(knitr::purl("eric_interface.Rmd", output = tempfile(), quiet = TRUE))
```


## Inputs and Outputs

Term groups are comma deliminated, and newline separated
For example:

> foo, bar
>
> foobie

is interpreted as

> ("foo" OR "bar") AND ("foobie")


Just a button that executes a hard coded ERIC search query, which is then displayed below

```{r echo=FALSE}

plot_size <- 1600


format_terms_input_to_search <- function(search_terms) {
  # TODO: Remove leading spaces from split inputs (More info below)

  # We split the string on new lines then pass the array of split strings to mapply which splits each line on commas
  split_input <-
    mapply(strsplit,
           strsplit(search_terms, "\n"),
           MoreArgs = list(split = ","))

  # We then combine the split strings with ORs on the same line and each line separated with ANDs
  # When we combine with ORs it produces a double space. This is because we're splitting on comma without the following space.
  # This could be changed if we want to disallow commas without spaces after or we could trim the spaces after.
  return(paste("terms: ", paste(
    mapply(paste, split_input, MoreArgs = list(collapse = " or ")), collapse = " and "
  )))
}

# search_terms is the string input from the terms_input textArea
format_terms_input_to_list <- function(search_terms) {
  # split on newlines to search term groups
  term_groups <- t(stringr::str_split(search_terms, "\n", simplify = TRUE))

  # split term groups on comma, needs whitespace trimmed from terms
  terms_list <- mapply(function(x) {
    stringr::str_split(x, ",")
  }, term_groups)

  return(rapply(terms_list, trimws, how = "replace"))
}

format_product_into_string <- function(product) {
    # We need to split on the same value as what is used in format_powerset
    mapply(function(x) { strsplit(x, "```") }, product)
}

product_is_empty <- function(product) {
  # First we create a list of booleans with each element representing if that index is not an empty string.
  # Then check if any are true
  return(!any(mapply(function(x) { return(x != "") }, product) == TRUE))
}

product_contains_empty <- function(product) {
  # First we create a list of booleans with each element representing if that index is not an empty string.
  # Then check if any are false
  return(any(mapply(function(x) { return(x != "") }, product) == FALSE))
}
```


## Input Panel
```{r echo=FALSE}

empty_space <- "Nothing"

# Helper Functions
split_terms_string <- function(str) {
    cartesian_product_of_terms <- str %>%
    format_terms_input_to_list %>%
    term_powerset %>%
    format_powerset %>%
    purrr::cross()
  
  cartesian_product_of_terms <- cartesian_product_of_terms[!mapply(product_is_empty, cartesian_product_of_terms)]

  contains_empty <- 
    cartesian_product_of_terms %>% 
    map(product_contains_empty)
  formatted_products <- cartesian_product_of_terms %>% 
    map(function(x) { return(x[x != ""]) }) %>%
    map(format_product_into_string)
  
  return(formatted_products)
}

##   formatted_products <- cartesian_product_of_terms %>% 
##    map(function(x) { return(x[x != ""]) }) %>%
##    map(format_product_into_string)

search_eric_from_products <- function(formatted_products, options) {
  
  eric_urls <- formatted_products %>%
    map(function(x) { create_eric_url(x, rows = 20, fields = list(list("peerreviewed", "'T'"))) })
 
  readable_terms <- mapply(function(product) {
      paste(mapply(function(x) { 
          paste(unlist(x), collapse = " or ")}, product), collapse = " and ") }, formatted_products)
  
  print(paste(readable_terms))
  
  eric_responses <- list()

  withProgress(message = "Searching ERIC\n", value = 0, {
    # Number of times we'll go through the loop
    n <- length(eric_urls)

    for (i in 1:n) {
      eric_responses[[i]] <- get_eric_json(eric_urls[[i]])

      # Increment the progress bar, and update the detail text.
      incProgress(1 / n, detail = paste("Searching URL", eric_urls[[i]]))
    }
  })
  
  names(eric_responses) <- readable_terms
  
  num_found <- mapply(function(x) { return(x$response$numFound) }, eric_responses)

  names(num_found) <- readable_terms
  
  return(num_found)
}

create_compare_graph <- function(first_set, second_set) {
  first_formatted <- mapply(function(x) {
          paste(unlist(x), collapse = " or ")}, format_product_into_string(first_set))
    
  first_formatted[[1]] <- empty_space
    
  second_formatted <- mapply(function(x) {
          paste(unlist(x), collapse = " or ")}, format_product_into_string(second_set))
    
  second_formatted[[1]] <- empty_space
    
  compare_matrix <- matrix(nrow = length(first_formatted), ncol = length(second_formatted))
    
  rownames(compare_matrix) <- first_formatted
    
  colnames(compare_matrix) <- second_formatted
    
  compare_matrix <- fill_compare_matrix(compare_matrix, num_found_for_terms)
  
  print(compare_matrix)
    
  return(renderTable(compare_matrix, align = "l", rownames = TRUE, bordered = TRUE))
}


fill_compare_matrix <- function(matrix, numbers) {
  find_string <- ""
  mapply(function(rowname) {
    mapply(function(colname) {
      if (rowname == empty_space) {
        if (colname == empty_space) {
          return()
        } 
        find_string <- colname
      }
      else if (colname == empty_space) {
        find_string <- rowname
      }
      else {
        find_string <- paste(rowname, "and", colname)
      }
      
      print(rowname)
      
      print(colname)
      
      matrix[rowname, colname] <<- numbers[find_string]
      
    }, colnames(matrix))
  }, rownames(matrix))
  
  return(matrix)
}
```

```{r eval=FALSE}
  withProgress(message = "Searching ERIC\n", value = 0, {
    # Number of times we'll go through the loop
    n <- length(formatted_products)

    for (i in 1:n) {
      url <- create_eric_url(formatted_products[[i]], rows = 20, fields = options)
      
      eric_responses[[i]] <- get_eric_json(url)

      # Increment the progress bar, and update the detail text.
      incProgress(1 / n, detail = url)
    }
  })
```

```{r echo=FALSE}
# Define UI
ui <- fluidPage(

  titlePanel("Search"),

  # Sidebar layout with input and output definitions
  sidebarLayout(
    
    # Sidebar panel for inputs
    sidebarPanel(

      # Input for terms and options
      textAreaInput("terms", "Terms", value = "test, terms\nmore, terms"),
      checkboxInput("peer", "Peer Reviewed", value = FALSE),
      actionButton("search", "Search", class = "btn-success"),
      br(),
      
    ),

    # Main panel for displaying outputs
    mainPanel(
      
      br(),

      # Output: Dropdown menu for term set selection
      uiOutput("term_dropdown"),
      
      # Output: Button to add a new tab
      uiOutput("add_tab"),
      
      # Output: Tabset w/ summary and comparison
      uiOutput("result_tabset")
    )
  )
)

num_found_for_terms <- list()

compare_count <- 1

summary_count <- 1

server <- function(input, output) {
  
#  observeEvent(input$add_tab, {
#    showModal(modalDialog(
#      wellPanel(actionButton("add_summary", "Summary", class = "btn-success", width = "49.5%"), actionButton("add_compare", "Compare", class = "btn-success", width = "49.5%")),
#      title = "Add Tab",
#      footer = modalButton("Dismiss"),
#      size = "m",
#      easyClose = TRUE,
#  ))
#  })
  
  observeEvent(input$term_dropdown, {
  
    if (all(input$term_dropdown != "")) {
    
    terms_list <- mapply(function(x) { paste(x, collapse = " or ") }, format_terms_input_to_list(input$terms))
    
    names(terms_list) <- terms_list
    
      
    terms_trimmed <- terms_list[!mapply(function(x) { all(input$term_dropdown == x) }, terms_list)]
        
    
    # Logic for the compare tab
    output$compare_dropdown <- renderUI({ selectInput(
      "compare_dropdown",
      "",
      c("Select A Compare Term Set" = "", terms_trimmed)) })
    
    
    # Logic for the summary tab
    # TODO: Add hasse diagram
    
    }
    else {
      output$compare_dropdown <- renderUI({ 
        verbatimTextOutput("placeholder")
        })
      output$placeholder <- renderText({"Select A Term Set First"})
    }
  })
  
  
  observeEvent(input$compare_dropdown, {
    if (all(input$compare_dropdown != "")) {
      output$compare_btn <- renderUI({actionButton("compare_btn", "Compare", class = "btn-success")})
    }
  })
  
  observeEvent(input$compare_btn, {
    
    first_term_set <- unlist(str_split(input$term_dropdown, " or "), recursive = FALSE) %>% powerset %>% format_powerset
    
    second_term_set <- unlist(str_split(input$compare_dropdown, " or "), recursive = FALSE) %>% powerset %>% format_powerset
    
    output$compare_table <- create_compare_graph(first_term_set, second_term_set)
    
  })
  
  observeEvent(input$search, {
    
    formatted_products <- split_terms_string(input$terms)
    
    options <- list()
    
    if (input$peer) {
      options[[length(options) + 1]] <- list("peerreviewed", "'T'")
    }
    
    if (length(options) == 0) {
      options[[1]] <- list("*")
    }
    
    num_found <- search_eric_from_products(formatted_products, options)
    
    terms_list <- format_terms_input_to_list(formatted_products)
    
    readable_terms <- mapply(function(product) {
      paste(mapply(function(x) {
          paste(unlist(x), collapse = " or ")}, product), collapse = " and ") }, formatted_products)
    
    num_found_for_terms <<- num_found 
    #data.frame("terms" = readable_terms, "found" = )
    
    terms_list <- mapply(function(x) { paste(x, collapse = " or ") }, format_terms_input_to_list(input$terms))
    
    names(terms_list) <- terms_list
    
    output$term_dropdown <- renderUI({
      selectInput(
      "term_dropdown",
      "",
      c("Select A Compare Term Set" = "", terms_list))
      })
    
    if (length(terms_list) != 1) { 
      
      output$result_tabset <- renderUI({ mainPanel(tabsetPanel(
            tabPanel("Summary", mainPanel(textOutput("summary"))),
            tabPanel("Compare", mainPanel(
                    uiOutput("compare_dropdown"),
                    uiOutput("compare_btn"),
                    br(),
                    tableOutput("compare_table"))))
            ) })
      
#      output$compare <- renderUI( { wellPanel(
#                    uiOutput("first_compare"),
#                    selectInput(
#                      "first_compare",
#                      "Select Term Sets",
#                      c("Select A Term Set" = "", terms_list))) } )
#      
#      output$first_compare <- renderUI({selectInput(
#                      "first_compare",
#                      "Select Term Sets",
#                      c("Select A Term Set" = "", terms_list))})
    }
    else {
      output$result_tabset <- renderUI({ tabsetPanel(type = "tabs",
      id = "result_tabset",
      tabPanel("Summary", textOutput("summary"))) })
    }
    
  })

}

shinyApp(ui, server)
```


```{r echo=FALSE}
inputPanel(
  textAreaInput("terms_input", "Search", rows = 3,
                value = "FAA, Part 147\ndistance learning, online education"),
  actionButton("display_button", "Display terms")
)
plotOutput("terms_output", height = plot_size)
```

### Button logic (hidden (for now))

```{r echo=FALSE}
display_button_event <- eventReactive(input$display_button, {
  
  cartesian_product_of_terms <- input$terms_input %>%
    format_terms_input_to_list %>%
    term_powerset %>%
    format_powerset %>%
    purrr::cross()
  
  cartesian_product_of_terms <- cartesian_product_of_terms[!mapply(product_is_empty, cartesian_product_of_terms)]

  contains_empty <- 
    cartesian_product_of_terms %>% 
    map(product_contains_empty)
  
  formatted_products <- cartesian_product_of_terms %>% 
    map(function(x) { return(x[x != ""]) }) %>%
    map(format_product_into_string)
    
  eric_urls <- formatted_products %>%
    map(function(x) { create_eric_url(x, rows = 20, fields = list(list("peerreviewed", "'T'"))) })
 
  readable_terms <- mapply(function(product) {
      paste(mapply(function(x) {
          paste(unlist(x), collapse = " or ")}, product), collapse = " and ") }, formatted_products)
  
  eric_responses <- list()

  withProgress(message = "Searching ERIC\n", value = 0, {
    # Number of times we'll go through the loop
    n <- length(eric_urls)

    for (i in 1:n) {
      eric_responses[[i]] <- get_eric_json(eric_urls[[i]])

      # Increment the progress bar, and update the detail text.
      incProgress(1 / n, detail = paste("Searching URL", eric_urls[[i]]))
    }
  })
  
  names(eric_responses) <- readable_terms

  num_found <- mapply(function(x) { return(x$response$numFound) }, eric_responses)

  names(num_found) <- readable_terms

  found_kable <- knitr::kable(
    num_found,
    align = "c",
    col.names = c("Number Found"),
    label = "ERIC Results",
    caption = "Number of results found")

  # return(found_kable, collapse = "\n")
  found_df <- data.frame(
    search = readable_terms,
    number_found = num_found
  )

  gplot <- ggplot(data = found_df, ggplot2::aes(x = search, y = number_found)) +
    geom_bar(stat = "identity")
  
  gplot <- gplot + coord_cartesian(ylim = c(-5, 250))

  return(gplot + theme(axis.text.x = element_text(size = 15, angle = -90, hjust = 0)))
})
```

## Visualizations

Ideas for helpful graphs:

* venn diagram
* flame chart
* something interactive? checkbox matrix?
* tree breakdowns, roots are total sums of term groups

```{r echo=FALSE}
output$terms_output <- renderPlot({
  display_button_event()},
  res = 72)
```
